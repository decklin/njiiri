#!/usr/bin/ruby

require 'rubygems'
require 'librmpd'
require 'thread'
require 'libglade2'
require 'cgi'

class WidgetBucket
  def initialize(glade)
    @glade = glade
  end
  def [](w)
    @glade.get_widget(w.to_s)
  end
end

class NjConfig
  attr_accessor :host, :port, :pass
  def initialize(path)
    defaults = { :host => 'localhost', :port => 6600, :password => nil }
    rc = begin
      File.open(path) do |yf|
        YAML::load(yf)
      end
    rescue
      {}
    end
    rc = defaults.merge(rc)
    @host = rc['host']
    @port = rc['port']
    @pass = rc['password']
  end
end

class Njiiri

  TITLE = "Njiiri MPD Client"
  NAME = "Njiiri"
  VERSION = "0.1"
  GLADE_PATH = "njiiri.glade"

  TITLE_FORMAT = "<big><big><b>%s</b></big></big>"
  ARTIST_FORMAT = "<big>%s</big>"
  ALBUM_FORMAT = "<small>%s</small>"
  POSITION_FORMAT = "%d:%02d / %d:%02d"
  WINDOW_FORMAT = "%s - %s"
  BLANK = ' '

  # CLASS

  def initialize(rc_path)
    @conf = NjConfig.new(rc_path)
    @glade = GladeXML.new(GLADE_PATH) { |handler| method(handler) }
    @w = WidgetBucket.new(@glade)
    @w[:host_entry].text = @conf.host
    @w[:port_entry].text = @conf.port.to_s
    @w[:pass_entry].text = @conf.pass
  end

  def connect
    @mpd = MPD.new @conf.host, @conf.port
    @mpd.register_callback(self.method('song_cb'), MPD::CURRENT_SONG_CALLBACK)
    @mpd.register_callback(self.method('time_cb'), MPD::TIME_CALLBACK)

    begin
      @mpd.connect true
      @mpd.password @conf.pass if @conf.pass
      @w[:connect_btn].stock_id = Gtk::Stock::DISCONNECT
      self.enable_toolbuttons(true)
      self.connected
    rescue
      self.enable_toolbuttons(false)
    end
  end

  def enable_toolbuttons(sensitive)
    %w{play_btn prev_btn next_btn open_btn saveas_btn clear_btn repeat_btn shuffle_btn}.each do |b|
      @glade.get_widget(b).sensitive = sensitive
    end
  end

  def connected
    if @mpd.playing?
      @w[:play_btn].stock_id = Gtk::Stock::MEDIA_PAUSE
    end

    @w[:repeat_btn].active = @mpd.repeat?
    @w[:shuffle_btn].active = @mpd.random?

    @old_volume = @mpd.volume
    @w[:volume_scale].value = @mpd.volume.to_f

    @status_msg = nil
    @status_ctx = @w[:player_status].get_context_id(TITLE)
    self.update_status
  end

  # MAIN WINDOW

  def on_quit(widget, event)
    @mpd.disconnect
    Gtk.main_quit
  end

  def on_info_box_size_allocate(widget, a)
    if @w[:cover_img].width_request == a.height
      @w[:cover_img].height_request = 1
    else
      @w[:cover_img].width_request = a.height
      @w[:cover_img].height_request = a.height
    end
  end

  # TOOLBAR

  def on_play_btn_clicked(widget)
    if @mpd.playing?
      @mpd.pause = true
      widget.stock_id = Gtk::Stock::MEDIA_PLAY
    else
      @mpd.pause = false
      widget.stock_id = Gtk::Stock::MEDIA_PAUSE
    end
  end

  def on_prev_btn_clicked
    @mpd.previous
  end

  def on_next_btn_clicked
    @mpd.next
  end

  def on_open_btn_clicked
    @w[:browser_win].show
  end

  def on_saveas_btn_clicked
    @w[:saveas_dlg].show
  end

  def on_clear_btn_clicked
    @mpd.clear
  end

  def on_repeat_btn_toggled(widget)
    @mpd.repeat = widget.active?
  end

  def on_shuffle_btn_toggled(widget)
    @mpd.random = widget.active?
  end

  def on_connect_btn_clicked(widget)
    if @mpd.connected?
      self.enable_toolbuttons(false)
      widget.stock_id = Gtk::Stock::CONNECT
      @mpd.disconnect
      self.update_info(nil)
      self.update_pos(0, 0)
      self.update_status
    else
      @w[:connect_dlg].show
    end
  end

  def on_volume_scale_value_changed(widget)
    if widget.value.to_i != @old_volume
      @old_volume = @mpd.volume = widget.value.to_i
      self.update_status
    end
  end

  # BROWSER WINDOW

  def on_close_btn_clicked(widget)
    @w[:browser_win].hide
  end

  # SAVE AS DIALOG

  def on_cancel_btn_clicked
    @w[:saveas_dlg].hide
  end

  def on_save_btn_clicked
    @mpd.save(@w[:name_entry].text)
    @w[:saveas_dlg].hide
  end

  # CONNECT DIALOG

  def on_conn_cancel_btn_clicked
    @w[:connect_dlg].hide
  end

  def on_do_connect_btn_clicked
    @w[:connect_dlg].hide
    @conf.host = @w[:host_entry].text
    @conf.port = @w[:port_entry].text.to_i
    @conf.pass = @w[:pass_entry].text
    self.connect
  end

  # CALLBACKS

  def song_cb(current)
    update_info(current)
  end

  def time_cb(elapsed, total)
    update_pos(elapsed, total)
  end

  # MISC

  def update_pos(elapsed, total)
    pos_bar = @w[:pos_bar]
    if total > 0:
      pos_bar.fraction = elapsed.to_f / total
      pos_bar.text = POSITION_FORMAT % \
        [elapsed / 60, elapsed % 60, total / 60, total % 60]
    else
      pos_bar.fraction = 0.0
      pos_bar.text = BLANK
    end
  end

  def update_info(current)
    if @mpd.connected? and current
      @w[:player_win].title = WINDOW_FORMAT % [current.artist, current.title]
      @w[:title_label].label = TITLE_FORMAT % CGI::escapeHTML(current.title)
      @w[:artist_label].label = ARTIST_FORMAT % CGI::escapeHTML(current.artist)
      @w[:album_label].label = ALBUM_FORMAT % CGI::escapeHTML(current.album)
      if @mpd.playing?
        elapsed, total = @mpd.status["time"].split(":").collect {|t| t.to_i }
        self.update_pos(elapsed, total)
      else
        self.update_pos(0, 0)
      end
    else
      @w[:player_win].title = NAME
      @w[:title_label].label = TITLE_FORMAT % BLANK
      @w[:artist_label].label = ARTIST_FORMAT % BLANK
      @w[:album_label].label = ALBUM_FORMAT % BLANK
    end
  end

  def update_status
    if @mpd.connected?
        if @status_msg
          @w[:player_status].remove(@status_ctx, @status_msg)
        end
        text = "Volume: #{@mpd.volume}%"
        @status_msg = @w[:player_status].push(@status_ctx, text)
    else
      @status_msg = @w[:player_status].push(@status_ctx, "Disconnected")
    end
  end

end

Gtk.init
njiiri = Njiiri.new(File.expand_path("~/.njiirirc"))
njiiri.connect
Gtk.main
