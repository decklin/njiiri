#!/usr/bin/ruby

require 'rubygems'
require 'librmpd'
require 'thread'
require 'libglade2'
require 'cgi'

class Njiiri

  TITLE = "Njiiri MPD Client"
  NAME = "Njiiri"
  VERSION = "0.1"
  GLADE_PATH = "njiiri.glade"

  # CLASS

  def initialize(rc_path)
    @conf = Conf.new(rc_path)
    @glade = GladeXML.new(GLADE_PATH) { |handler| method(handler) }

    @status_ctx = @glade['player_status'].get_context_id(NAME)
    @status_msg = nil

    @tree_store = Gtk::TreeStore.new(String, String, String, String)
    @glade['playlist_tree'].model = @tree_store

    @renderer = Gtk::CellRendererText.new
    %w{Title Artist Album Time}.each_with_index do |t, i|
      col = Gtk::TreeViewColumn.new(t, @renderer, :text => i)
      col.resizable = true
      @glade['playlist_tree'].append_column(col)
    end

    @glade['host_entry'].text = @conf.serv[:host]
    @glade['port_entry'].text = @conf.serv[:port].to_s
    @glade['pass_entry'].text = @conf.serv[:pass].to_s

    @glade['player_win'].set_default_size(@conf.geom[:player][:w],
                                          @conf.geom[:player][:h])
    @glade['browser_win'].set_default_size(@conf.geom[:browser][:w],
                                           @conf.geom[:browser][:h])
    @glade['player_win'].show
  end

  def connect
    @mpd = MPD.new(@conf.serv[:host], @conf.serv[:port])
    @mpd.register_callback(self.method(:playlist_cb), MPD::PLAYLIST_CALLBACK)
    @mpd.register_callback(self.method(:song_cb), MPD::CURRENT_SONG_CALLBACK)
    @mpd.register_callback(self.method(:state_cb), MPD::STATE_CALLBACK)
    @mpd.register_callback(self.method(:time_cb), MPD::TIME_CALLBACK)

    begin
      @mpd.connect true
      @mpd.password @conf.serv[:pass] if @conf.serv[:pass]
      @glade['connect_btn'].stock_id = Gtk::Stock::DISCONNECT
      self.enable_toolbuttons(true)
      self.connected
    rescue
      self.enable_toolbuttons(false)
    end

    self.update_status
  end

  def enable_toolbuttons(sensitive)
    %w{play prev next open saveas clear repeat shuffle}.each do |b|
      @glade[b+'_btn'].sensitive = sensitive
    end
  end

  def connected
    @glade['play_btn'].stock_id = Gtk::Stock::MEDIA_PAUSE if @mpd.playing?
    @glade['repeat_btn'].active = @mpd.repeat?
    @glade['shuffle_btn'].active = @mpd.random?

    @volume = @mpd.volume
    @glade['volume_scale'].value = @volume.to_f

    self.update_info(@mpd.current_song)
  end

  # MAIN WINDOW

  def on_player_win_delete(widget, e)
    @mpd.disconnect
    @conf.save
    Gtk.main_quit
  end

  def on_info_box_size_allocate(widget, a)
    if @glade['cover_img'].width_request == a.height
      @glade['cover_img'].height_request = 1
    else
      @glade['cover_img'].width_request = a.height
      @glade['cover_img'].height_request = a.height
    end
  end

  def on_player_win_size_allocate(widget, a)
    @conf.geom[:player][:w] = a.width
    @conf.geom[:player][:h] = a.height
  end

  def on_browser_win_size_allocate(widget, a)
    @conf.geom[:browser][:w] = a.width
    @conf.geom[:browser][:h] = a.height
  end

  def on_pos_bar_button_press_event(widget, e)
    if @mpd.connected? and @mpd.playing?
      seek = (e.x / widget.allocation.width) * @mpd.current_song.time.to_i
      @mpd.seek(@mpd.current_song.pos, seek.to_i)
    end
  end

  def on_playlist_tree_row_activated(widget, path, col)
    iter = @tree_store.get_iter(path)
  end

  # TOOLBAR

  def on_play_btn_clicked(widget)
    if @mpd.stopped?
      @mpd.play
      widget.stock_id = Gtk::Stock::MEDIA_PAUSE
    elsif @mpd.paused?
      @mpd.pause = false
      widget.stock_id = Gtk::Stock::MEDIA_PAUSE
    else
      @mpd.pause = true
      widget.stock_id = Gtk::Stock::MEDIA_PLAY
    end
  end

  def on_prev_btn_clicked
    @mpd.previous
  end

  def on_next_btn_clicked
    @mpd.next
  end

  def on_open_btn_clicked
    @glade['browser_win'].show
  end

  def on_saveas_btn_clicked
    @glade['saveas_dlg'].show
  end

  def on_clear_btn_clicked
    @mpd.clear
  end

  def on_repeat_btn_toggled(widget)
    @mpd.repeat = widget.active?
  end

  def on_shuffle_btn_toggled(widget)
    @mpd.random = widget.active?
  end

  def on_connect_btn_clicked(widget)
    if @mpd.connected?
      self.enable_toolbuttons(false)
      widget.stock_id = Gtk::Stock::CONNECT
      @mpd.disconnect
      self.update_info(nil)
      self.update_pos(-1)
      self.update_playlist
      self.update_status
    else
      @glade['connect_dlg'].show
    end
  end

  def on_volume_scale_value_changed(widget)
    if widget.value.to_i != @volume
      @volume = @mpd.volume = widget.value.to_i
      self.update_status
    end
  end

  # BROWSER WINDOW

  def on_browser_win_delete(widget, e)
    widget.hide
  end

  def on_close_btn_clicked(widget)
    @glade['browser_win'].hide
  end

  # SAVE AS DIALOG

  def on_cancel_btn_clicked
    @glade['saveas_dlg'].hide
  end

  def on_save_btn_clicked
    @mpd.save(@glade['name_entry'].text)
    @glade['saveas_dlg'].hide
  end

  # CONNECT DIALOG

  def on_conn_cancel_btn_clicked
    @glade['connect_dlg'].hide
  end

  def on_do_connect_btn_clicked
    @glade['connect_dlg'].hide
    @conf.serv[:host] = @glade['host_entry'].text
    @conf.serv[:port] = @glade['port_entry'].text.to_i
    @conf.serv[:pass] = @glade['pass_entry'].text
    @conf.serv[:pass] = nil if @conf.serv[:pass].empty?
    self.connect
  end

  # CALLBACKS

  def playlist_cb(playlist)
    update_playlist
  end

  def song_cb(current)
    update_info(current)
  end

  def state_cb(newstate)
    case newstate
      when "play"
        @glade['play_btn'].stock_id = Gtk::Stock::MEDIA_PAUSE
      when "pause"
        @glade['play_btn'].stock_id = Gtk::Stock::MEDIA_PLAY
      when "stop"
        @glade['play_btn'].stock_id = Gtk::Stock::MEDIA_PLAY
        update_pos(-1)
    end
  end

  def time_cb(elapsed, total)
    update_pos(elapsed, total)
  end

  # MISC

  def update_playlist
    @tree_store.clear
    if @mpd.connected?
      @mpd.playlist.each do |song|
        iter = @tree_store.append(nil)
        iter[0] = Format.pad(song.title, "-")
        iter[1] = Format.pad(song.artist, "-")
        iter[2] = Format.pad(song.album, "-")
        iter[3] = Format.pos(song.time.to_i)
      end
    end
  end

  def update_info(current)
    current ||= MPD::Song.new
    @glade['player_win'].title = Format.window(current.artist, current.title)
    @glade['title_label'].label = Format.title(current.title)
    @glade['artist_label'].label = Format.artist(current.artist)
    @glade['album_label'].label = Format.album(current.album)
  end

  def update_pos(elapsed, total = 0)
    if @mpd.connected? and @mpd.current_song and total == 0
      total = @mpd.current_song.time.to_i
    end
    if total > 0
      if elapsed >= 0
        @glade['pos_bar'].text = Format.pos(elapsed, total)
        @glade['pos_bar'].fraction = elapsed.to_f / total
      else
        @glade['pos_bar'].text = Format.pos(total)
        @glade['pos_bar'].fraction = 0.0
      end
    else
      if elapsed > 0
        @glade['pos_bar'].text = Format.pos(elapsed)
        @glade['pos_bar'].pulse
      else
        @glade['pos_bar'].text = Format.pos
        @glade['pos_bar'].fraction = 0.0
      end
    end
  end

  def update_status
    if @mpd.connected?
      text = "Volume: #{@volume}%"
      @glade['player_status'].remove(@status_ctx, @status_msg) if @status_msg
      @status_msg = @glade['player_status'].push(@status_ctx, text)
    else
      @status_msg = @glade['player_status'].push(@status_ctx, "Disconnected")
    end
  end

end

class Format
  class << self
    def pad(s, p); s && s != "" ? s : p; end
    def h(s); CGI::escapeHTML(pad(s, " ")); end
    def pos(*times)
      pad(times.collect {|t| "%d:%02d" % [t/60, t%60] }.join(" / "), " ")
    end
    def window(*parts)
      pad(parts.compact.join(" - "), Njiiri::NAME)
    end
    def title(title)
      "<big><big><b>#{h(title)}</b></big></big>"
    end
    def artist(artist)
      "<big>#{h(artist)}</big>"
    end
    def album(album)
      "<small>#{h(album)}</small>"
    end
  end
end

class Conf

  DEFAULTS =
    { :server => { :host => 'localhost', :port => 6600, :pass => nil },
      :geometry =>
        { :player =>
            { :x => 0, :y => 0, :w => 620, :h => 440, :cover => 100 },
          :browser =>
            { :x => 0, :y => 0, :w => 620, :h => 440, :cover => 100 } } }

  attr_accessor :serv, :geom

  def initialize(path)
    @path = path
    @rc = DEFAULTS.merge begin
      File.open(@path) { |f| YAML::load(f) }
    rescue
      {}
    end
    @serv = @rc[:server]
    @geom = @rc[:geometry]
  end

  def save
    begin
      File.open(@path, 'w') { |f| YAML::dump(@rc, f) }
    rescue
    end
  end

end

if __FILE__ == $0
  Gtk.init
  njiiri = Njiiri.new(File.expand_path("~/.njiirirc"))
  njiiri.connect
  Gtk.main
end
