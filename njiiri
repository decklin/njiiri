#!/usr/bin/ruby

require 'rubygems'
require 'librmpd'
require 'thread'
require 'libglade2'
require 'cgi'
require 'yaml'

class Hash
  def deep_merge(h)
    t = dup
    h.each do |k, v|
      if t[k].kind_of? Hash and v.kind_of? Hash
        t[k] = t[k].deep_merge(v)
      else
        t[k] = v
      end
    end
    t
  end
end

class MPD
  def lsinfo(path = "/", type = :files)
    response = send_command "lsinfo \"#{path}\""
    case type
      when :files
        filter_response response, /\Afile: /i
      when :directories
        filter_response response, /\Adirectory: /i
      when :playlists
        filter_response response, /\Aplaylist: /i
    end
  end
  def listallinfo(path=nil)
    songs(path)
  end
  class Song
    def id; self['id']; end
  end
end

class Njiiri

  TITLE = "Njiiri MPD Client"
  NAME = "Njiiri"
  VERSION = "0.1"
  GLADE_PATH = "njiiri.glade"

  PLAYER_COLS = [ [ "", 40, String, ],
                  [ "Title", 180, String, ],
                  [ "Artist", 160, String, ],
                  [ "Album", 140, String, ],
                  [ "Time", 40, String, ],
                  [ :id, nil, String, ],
                  [ :cur, nil, Integer, ] ]
  BOOKMK_COLS = [ [ "Places", 0, String ],
                  [ :cb, nil, Proc ] ]
  BROWSE_COLS = [ [ "", 40, String ],
                  [ "Title", 140, String ],
                  [ "Artist", 120, String ],
                  [ "Album", 100, String ],
                  [ "Time", 40, String ],
                  [ :path, nil, String ],
                  [ :cb, nil, Proc ] ]

  # CLASS

  @@callbacks = {}

  def initialize(rc_path)
    @conf = Conf.new(rc_path)
    @glade = GladeXML.new(GLADE_PATH) {|handler| method(handler) }

    @status_ctx = @glade['player_status'].get_context_id(NAME)
    @status_msg = nil
    @last_version = 0
    @btab = {}
    @queued = {}

    rend = Gtk::CellRendererText.new
    rend.ellipsize = Pango::ELLIPSIZE_END

    @player_tree_store = Gtk::TreeStore.new(*PLAYER_COLS.collect{|x| x[2] })
    @glade['playlist_tree'].model = @player_tree_store
    @glade['playlist_tree'].selection.mode = Gtk::SELECTION_MULTIPLE

    PLAYER_COLS.each_with_index do |spec, n|
      name, width = spec
      if width
        col = Gtk::TreeViewColumn.new(name, rend, :text => n, :weight => 6)
        col.sizing = Gtk::TreeViewColumn::FIXED
        col.fixed_width = width
        col.resizable = true
        @glade['playlist_tree'].append_column(col)
      end
    end

    rend = Gtk::CellRendererText.new
    rend.ellipsize = Pango::ELLIPSIZE_END

    @bookmarks_tree_store = Gtk::TreeStore.new(*BOOKMK_COLS.collect{|x| x[2] })
    @glade['bookmarks_tree'].model = @bookmarks_tree_store

    BOOKMK_COLS.each_with_index do |spec, n|
      name, width = spec
      if width
        col = Gtk::TreeViewColumn.new(name, rend, :text => n)
        col.resizable = false
        @glade['bookmarks_tree'].append_column(col)
      end
    end

    rend = Gtk::CellRendererText.new
    rend.ellipsize = Pango::ELLIPSIZE_END

    @files_tree_store = Gtk::TreeStore.new(*BROWSE_COLS.collect{|x| x[2] })
    @glade['files_tree'].model = @files_tree_store
    @glade['files_tree'].selection.mode = Gtk::SELECTION_MULTIPLE

    BROWSE_COLS.each_with_index do |spec, n|
      name, width = spec
      if width
        col = Gtk::TreeViewColumn.new(name, rend, :text => n)
        col.sizing = Gtk::TreeViewColumn::FIXED
        col.fixed_width = width
        col.resizable = true
        @glade['files_tree'].append_column(col)
      end
    end

    @glade['host_entry'].text = @conf.serv[:host]
    @glade['port_entry'].text = @conf.serv[:port].to_s
    @glade['password_entry'].text = @conf.serv[:password].to_s

    x, y, h, w = [:x, :y, :h, :w].collect {|d| @conf.geom[:player][d] }
    @glade['player_win'].set_default_size(w, h)
    @glade['player_win'].move(x, y)
    @glade['main_pane'].set_position(@conf.geom[:player][:pane])

    x, y, h, w = [:x, :y, :h, :w].collect {|d| @conf.geom[:browser][d] }
    @glade['browser_win'].set_default_size(w, h)
    @glade['browser_win'].move(x, y)
    @glade['files_pane'].set_position(@conf.geom[:browser][:pane])

    @glade['player_win'].show
  end

  def connect
    @mpd = MPD.new(@conf.serv[:host], @conf.serv[:port])
    @@callbacks.each {|tag, name| @mpd.register_callback(method(name), tag) }
    begin
      @mpd.connect(true)
      @mpd.password(@conf.serv[:password]) if @conf.serv[:password]
      @glade['connect_btn'].stock_id = Gtk::Stock::DISCONNECT
    rescue
      self.disconnected
      throw
    end
  end

  def connected
    self.enable_toolbuttons(true)
    @glade['connect_btn'].stock_id = Gtk::Stock::DISCONNECT
    @glade['play_btn'].stock_id = Gtk::Stock::MEDIA_PAUSE if @mpd.playing?
    @glade['repeat_btn'].active = @mpd.repeat?
    @glade['shuffle_btn'].active = @mpd.random?
    @glade['volume_scale'].value = @mpd.volume
    self.refresh_info(@mpd.current_song)
    self.refresh_status
  end

  def disconnected
    self.enable_toolbuttons(false)
    @glade['connect_btn'].stock_id = Gtk::Stock::CONNECT
    @player_tree_store.clear
    self.refresh_info(nil)
    self.refresh_pos(-1)
    self.refresh_status
  end

  def enable_toolbuttons(sensitive)
    %w{play prev next open saveas clear repeat shuffle}.each do |b|
      @glade["#{b}_btn"].sensitive = sensitive
    end
  end

  # MAIN WINDOW

  def on_player_win_delete(widget, e)
    @mpd.disconnect
    @conf.save
    Gtk.main_quit
  end

  def on_info_box_size_allocate(widget, a)
    if @glade['cover_img'].width_request == a.height
      @glade['cover_img'].height_request = 1
    else
      @glade['cover_img'].width_request = a.height
      @glade['cover_img'].height_request = a.height
    end
  end

  def on_player_win_size_allocate(widget, a)
    @conf.geom[:player][:w] = a.width
    @conf.geom[:player][:h] = a.height
    false
  end

  def on_player_win_configure_event(widget, e)
    @conf.geom[:player][:x] = e.x
    @conf.geom[:player][:y] = e.y
    false
  end

  def on_browser_win_size_allocate(widget, a)
    @conf.geom[:browser][:w] = a.width
    @conf.geom[:browser][:h] = a.height
    false
  end

  def on_browser_win_configure_event(widget, e)
    @conf.geom[:browser][:x] = e.x
    @conf.geom[:browser][:y] = e.y
    false
  end

  def on_pos_bar_button_press_event(widget, e)
    if @mpd.connected? and @mpd.playing?
      seek = (e.x / widget.allocation.width) * @mpd.current_song.time.to_i
      @mpd.seek(@mpd.current_song.pos, seek.to_i)
    end
  end

  def on_playlist_tree_row_activated(widget, path, col)
    iter = @player_tree_store.get_iter(path)
    @mpd.seekid(iter[5], 0)
  end

  def on_playlist_tree_key_press_event(widget, e)
    if e.keyval == Gdk::Keyval::GDK_Delete
      @glade['playlist_tree'].selection.selected_each do |model, path, iter|
        @glade['playlist_tree'].selection.unselect_iter(iter)
        @mpd.deleteid(iter[5])
      end
    end
  end

  # TOOLBAR

  def on_play_btn_clicked(widget)
    if @mpd.stopped?
      @mpd.play
      widget.stock_id = Gtk::Stock::MEDIA_PAUSE
    elsif @mpd.paused?
      @mpd.pause = false
      widget.stock_id = Gtk::Stock::MEDIA_PAUSE
    else
      @mpd.pause = true
      widget.stock_id = Gtk::Stock::MEDIA_PLAY
    end
  end

  def on_prev_btn_clicked
    @mpd.previous
  end

  def on_next_btn_clicked
    @mpd.next
  end

  def on_open_btn_clicked
    @glade['browser_win'].show
  end

  def on_saveas_btn_clicked
    @glade['saveas_dlg'].show
  end

  def on_clear_btn_clicked
    @mpd.clear
  end

  def on_repeat_btn_toggled(widget)
    @mpd.repeat = widget.active?
  end

  def on_shuffle_btn_toggled(widget)
    @mpd.random = widget.active?
  end

  def on_connect_btn_clicked(widget)
    if @mpd.connected?
      @mpd.disconnect
      self.disconnected
    else
      @glade['connect_dlg'].show
    end
  end

  def on_volume_scale_value_changed(widget)
    queue :change_volume, widget.value.to_i
  end

  def change_volume(vol)
    @mpd.volume = vol
  end

  # BROWSER WINDOW

  def on_browser_win_show
    bookmarks = [ [ "Library", proc { reset_pwd } ],
                  [ "Search", proc { activate_search_entry("_Search:") } ],
                  [ "-", proc { } ] ] +
                @mpd.playlists.collect { |pl| [ pl, proc { @mpd.load(pl) } ] }
    @bookmarks_tree_store.clear
    bookmarks.each do |n, p|
      iter = @bookmarks_tree_store.append(nil)
      iter[0] = n
      iter[1] = p
    end
  end

  def add_pwd(dir)
    @pwd << dir

    @glade['breadcrumb_box'].children[1..-1].each_with_index do |child, i|
      if child.label != @pwd[i] or i >= @pwd.length-1
        @glade['breadcrumb_box'].remove(child)
        @btab.delete(child)
      end
    end

    btn = Gtk::Button.new(dir, false)
    @btab[btn] = @pwd.join("/")
    btn.signal_connect("clicked") {|w| up_pwd(@btab[w].split("/")) }
    @glade['breadcrumb_box'].add(btn)
    btn.show

    load_pwd
  end

  def load_pwd
    @files_tree_store.clear
    pwd = @pwd.join("/")
    @mpd.lsinfo(pwd, :directories).each do |path|
      dir = File.basename(path)
      iter = @files_tree_store.append(nil)
      iter[0] = "D"
      iter[1], iter[2], iter[3], iter[4] = dir, "-", "-", "-"
      iter[5] = path
      iter[6] = proc { add_pwd(dir) }
    end
    @mpd.lsinfo(pwd, :files).each do |path|
      song = @mpd.listallinfo(path)[0]
      iter = @files_tree_store.append(nil)
      iter[0] = "F"
      iter[1], iter[2], iter[3], iter[4] = Format.all(song, "-")
      iter[5] = path
      iter[6] = proc { @mpd.add path }
    end
  end

  def reset_pwd
    @pwd = [];
    load_pwd
  end

  def up_pwd(wd)
    @pwd = wd;
    load_pwd
  end

  def on_bookmarks_tree_row_activated(widget, path, col)
    iter = @bookmarks_tree_store.get_iter(path)
    iter[1].call
  end

  def on_files_tree_row_activated(widget, path, col)
    iter = @files_tree_store.get_iter(path)
    iter[6].call
  end

  def on_browser_win_key_press_event(widget, e)
    if !@glade['search_entry'].has_focus? and e.keyval == "/"[0]
      @glade['loc_btn'].active = true
      @glade['search_entry'].text = "http://"
      @glade['search_entry'].grab_focus
      @glade['search_entry'].position = -1
      true
    else
      false
    end
  end

  def on_add_btn_clicked(widget)
    if @glade['search_entry'].has_focus?
      begin
        @mpd.add(@glade['search_entry'].text)
        @glade['search_entry'].text = ""
      rescue RuntimeError
      end
    else
      if @glade['files_tree'].selection.selected_rows.empty?
        @glade['files_tree'].model.each do |model, path, iter|
          @mpd.add(iter[5])
        end
      else
        @glade['files_tree'].selection.selected_each do |model, path, iter|
          @mpd.add(iter[5])
        end
      end
    end
  end

  def on_insert_btn_clicked(widget)
    pos = @mpd.status['song'].to_i + 1
    @glade['files_tree'].selection.selected_each do |model, path, iter|
      @mpd.add(iter[5])
      @mpd.move(@mpd.playlist.length - 1, pos)
      pos += 1
    end
  end

  def on_loc_btn_toggled(widget)
    if widget.active?
      activate_search_entry("_Location:")
    else
      @glade['search_hbox'].hide
    end
  end

  def on_root_btn_clicked(widget)
    reset_pwd
  end

  def on_update_btn_clicked(widget)
    @mpd.update
  end

  def on_browser_win_delete(widget, e)
    widget.hide
  end

  def on_close_btn_clicked(widget)
    @glade['browser_win'].hide
  end

  def activate_search_entry(label)
    @glade['search_hbox'].show
    @glade['search_label'].label = label
    @glade['search_entry'].grab_focus
  end

  # SAVE AS DIALOG

  def on_cancel_btn_clicked
    @glade['saveas_dlg'].hide
  end

  def on_save_btn_clicked
    @mpd.save(@glade['name_entry'].text)
    @glade['saveas_dlg'].hide
  end

  # CONNECT DIALOG

  def on_conn_cancel_btn_clicked
    @glade['connect_dlg'].hide
  end

  def on_do_connect_btn_clicked
    @glade['connect_dlg'].hide
    @conf.serv[:host] = @glade['host_entry'].text
    @conf.serv[:port] = @glade['port_entry'].text.to_i
    if @glade['password_entry'].text.empty?
      @conf.serv[:password] = nil
    else
      @conf.serv[:password] = @glade['password_entry'].text
    end
    begin
      self.connect
    rescue
    end
  end

  # CALLBACKS

  def queue(meth, *args)
    @queued[meth] = args
  end

  def refresh
    @queued.each {|meth, args| self.send(meth, *args) }
    @queued.clear
  end

  def self.def_cb(name, tag, &block)
    @@callbacks[tag] = "_cb_#{tag}"
    class_eval do
      define_method name, &block
      define_method @@callbacks[tag] do |*args|
        queue name, *args
      end
    end
  end

  def_cb :got_playlist, MPD::PLAYLIST_CALLBACK do |version|
    rebuild_playlist(version)
    refresh_playlist
    refresh_status
  end

  def_cb :got_song, MPD::CURRENT_SONG_CALLBACK do |current|
    refresh_info(current)
    refresh_playlist
  end

  def_cb :got_state, MPD::STATE_CALLBACK do |state|
    case state
      when "play"
        @glade['play_btn'].stock_id = Gtk::Stock::MEDIA_PAUSE
      when "pause"
        @glade['play_btn'].stock_id = Gtk::Stock::MEDIA_PLAY
      when "stop"
        @glade['play_btn'].stock_id = Gtk::Stock::MEDIA_PLAY
        refresh_pos(-1)
    end
  end

  def_cb :got_volume, MPD::VOLUME_CALLBACK do |vol|
    @glade['volume_scale'].value = vol
  end

  def_cb :got_time, MPD::TIME_CALLBACK do |elapsed, total|
    refresh_pos(elapsed, total)
  end

  def_cb :got_connection, MPD::CONNECTION_CALLBACK do |up|
    if up
      self.connected
    else
      self.disconnected
    end
  end

  # MISC

  def refresh_playlist
    if @mpd.connected?
      cur_id = @mpd.status['songid']
      @player_tree_store.each do |model, path, iter|
        iter[6] = iter[5] == cur_id ? Pango::WEIGHT_BOLD : Pango::WEIGHT_NORMAL
      end
    end
  end

  def rebuild_playlist(version)
    if @mpd.connected?
      changes = @mpd.playlist_changes(@last_version)
      changes.each do |song|
        iter = @player_tree_store.get_iter(song["pos"]) \
            || @player_tree_store.append(nil)
        iter[1], iter[2], iter[3], iter[4] = Format.all(song, "-")
        iter[5] = song.id
      end

      len = @mpd.status["playlistlength"].to_i
      n = 0
      @player_tree_store.each do |model, path, iter|
        n += 1
        if n > len
          1 while @player_tree_store.remove(iter)
        end
      end
      @last_version = version
    end
  end

  def refresh_info(current)
    title, artist, album, time, track = Format.all(current)
    @glade['title_label'].label = Format.title(title)
    @glade['artist_label'].label = Format.artist(artist)
    @glade['album_label'].label = Format.album(album, track)
    @glade['player_win'].title = Format.window(artist, title)
  end

  def refresh_pos(elapsed, total = 0)
    if @mpd.connected? and @mpd.current_song and total == 0
      total = @mpd.current_song.time.to_i
    end
    if total > 0
      if elapsed >= 0
        @glade['pos_bar'].text = Format.pos(elapsed, total)
        @glade['pos_bar'].fraction = [elapsed.to_f / total, 1].min
      else
        @glade['pos_bar'].text = Format.pos(total)
        @glade['pos_bar'].fraction = 0.0
      end
    else
      if elapsed > 0
        @glade['pos_bar'].text = Format.pos(elapsed)
        @glade['pos_bar'].pulse
      else
        @glade['pos_bar'].text = Format.pos()
        @glade['pos_bar'].fraction = 0.0
      end
    end
  end

  def refresh_status
    if @mpd.connected?
      ptime = @mpd.playlist.inject(0) {|m, s| m + s.time.to_i }
      plen = @mpd.status['playlistlength'].to_i
      dbtime = @mpd.stats['db_playtime'].to_i
      dblen = @mpd.stats['songs'].to_i
      updated = Time.at(@mpd.stats['db_update'].to_i)
      items = [ "Playlist: #{Format.pos(ptime)} (#{plen} songs)",
                "Library: #{Format.pos(dbtime)} (#{dblen} songs)",
                "Updated: #{updated.strftime('%x %X')}" ]
    else
      items = [ "Disconnected" ]
    end
    @glade['player_status'].remove(@status_ctx, @status_msg) if @status_msg
    @status_msg = @glade['player_status'].push(@status_ctx, items.join(", "))
  end

end

class Format
  class << self
    def all(song, default=nil)
      if song
        dir, base = song.file =~ /^http:/ ? song.file : File.split(song.file)
        [ a(song.title, base, default),
          a(song.artist, song.name, default),
          a(song.album, dir, default),
          song.time ? pos(song.time.to_i) : "∞",
          song.track ]
      end
    end
    def a(*l)
      l.find {|x| not (x.nil? or x.empty?) }
    end
    def h(s)
      CGI::escapeHTML(a(s, " "))
    end
    def m(t)
      m, s = t.divmod(60); return "%d:%02d" % [m, s] if m < 80
      h, m = m.divmod(60); return "%d:%02d:%02d" % [h, m, s] if h < 24
      d, h = h.divmod(24); return "%dd %dh %dm" % [d, h, m]
    end
    def pos(*times)
      a(times.collect {|t| m(t) }.join(" / "), " ")
    end
    def window(*parts)
      a(parts.compact.join(" - "), Njiiri::NAME)
    end
    def title(title)
      "<big><big><b>#{h(title)}</b></big></big>"
    end
    def artist(artist)
      "<big>#{h(artist)}</big>"
    end
    def album(album, track = nil)
      track = "track #{track}, " if track
      "<small>#{track}<i>#{h(album)}</i></small>"
    end
  end
end

class Conf

  DEFAULTS =
    { :server => { :host => 'localhost', :port => 6600, :password => nil },
      :geometry =>
        { :player =>
            { :x => 0, :y => 0, :w => 620, :h => 400, :pane => 80 },
          :browser =>
            { :x => 0, :y => 0, :w => 600, :h => 400, :pane => 100 } } }

  attr_accessor :serv, :geom

  def initialize(path)
    @path = path
    @rc = DEFAULTS.deep_merge begin
      File.open(@path) {|f| YAML::load(f) }
    rescue
      {}
    end
    @serv = @rc[:server]
    @geom = @rc[:geometry]
  end

  def save
    begin
      File.open(@path, 'w') {|f| YAML::dump(@rc, f) }
    rescue
    end
  end

end

if __FILE__ == $0
  Gtk.init
  njiiri = Njiiri.new(File.expand_path("~/.njiirirc"))
  begin
    njiiri.connect
    njiiri.reset_pwd
  rescue
  end
  Gtk.timeout_add(100) { njiiri.refresh }
  Gtk.main
end
